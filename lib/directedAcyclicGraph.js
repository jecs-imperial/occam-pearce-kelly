'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Vertex = require('./vertex'),
    arrayUtil = require('./util/array');

var DirectedAcyclicGraph = function () {
  function DirectedAcyclicGraph(vertexMap) {
    _classCallCheck(this, DirectedAcyclicGraph);

    this.vertexMap = vertexMap;
  }

  _createClass(DirectedAcyclicGraph, [{
    key: 'addVertexByVertexName',
    value: function addVertexByVertexName(vertexName) {
      var vertexPresent = this.vertexMap.hasOwnProperty(vertexName);

      if (!vertexPresent) {
        var vertexNames = Object.keys(this.vertexMap),
            vertexNamesLength = vertexNames.length,
            name = vertexName,
            ///
        index = vertexNamesLength,
            ///
        _vertex = Vertex.fromNameAndIndex(name, index);

        this.vertexMap[vertexName] = _vertex;
      }

      var vertex = this.vertexMap[vertexName];

      return vertex;
    }
  }, {
    key: 'addEdgeByVertexNames',
    value: function addEdgeByVertexNames(sourceVertexName, targetVertexName) {
      var cyclicVertices = null;

      if (sourceVertexName === targetVertexName) {
        var cyclicVertexName = sourceVertexName,
            ///
        cyclicVertex = this.vertexMap[cyclicVertexName];

        cyclicVertices = [cyclicVertex];
      } else {
        var sourceVertex = this.addVertexByVertexName(sourceVertexName),
            targetVertex = this.addVertexByVertexName(targetVertexName),
            edgePresent = sourceVertex.isEdgePresentByTargetVertex(targetVertex);

        if (!edgePresent) {
          var sourceVertexIndex = sourceVertex.getIndex(),
              targetVertexIndex = targetVertex.getIndex(),
              invalidatingEdge = sourceVertexIndex > targetVertexIndex;

          if (invalidatingEdge) {
            cyclicVertices = this.validateEdge(sourceVertex, targetVertex);
          }

          var cycleMissing = cyclicVertices === null; ///

          if (cycleMissing) {
            var immediatePredecessorVertex = sourceVertex,
                ///
            immediateSuccessorVertex = targetVertex; ///

            immediatePredecessorVertex.addImmediateSuccessorVertex(immediateSuccessorVertex);

            immediateSuccessorVertex.addImmediatePredecessorVertex(immediatePredecessorVertex);
          }
        }
      }

      var cyclicVertexNames = void 0;

      if (cyclicVertices !== null) {
        cyclicVertexNames = cyclicVertices.forEach(function (cyclicVertex) {
          var cyclicVertexName = cyclicVertex.getName();

          return cyclicVertexName;
        });
      }

      return cyclicVertexNames;
    }
  }, {
    key: 'addEdge',
    value: function addEdge(edge) {
      var sourceVertexName = edge.getSourceVertexName(),
          targetVertexName = edge.getTargetVertexName();

      this.addEdgeByVertexNames(sourceVertexName, targetVertexName);
    }
  }, {
    key: 'validateEdge',
    value: function validateEdge(sourceVertex, targetVertex) {
      var cyclicVertices = null;

      var forwardsAffectedVertices = targetVertex.getForwardsAffectedVertices(sourceVertex),
          lastForwardsAffectedVertex = arrayUtil.last(forwardsAffectedVertices),
          cyclePresent = lastForwardsAffectedVertex === sourceVertex;

      if (cyclePresent) {
        cyclicVertices = forwardsAffectedVertices;
      } else {
        var backwardsAffectedVertices = sourceVertex.getBackwardsAffectedVertices();

        DirectedAcyclicGraph.sortVertices(backwardsAffectedVertices);

        DirectedAcyclicGraph.sortVertices(forwardsAffectedVertices);

        var affectedVertices = [].concat(backwardsAffectedVertices).concat(forwardsAffectedVertices),
            affectedVertexIndices = affectedVertices.map(function (affectedVertex) {
          var affectedVertexIndex = affectedVertex.getIndex();

          return affectedVertexIndex;
        });

        affectedVertexIndices.sort();

        affectedVertices.forEach(function (affectedVertex, index) {
          var affectedVertexIndex = affectedVertexIndices[index];

          affectedVertex.setIndex(affectedVertexIndex);
        });
      }

      return cyclicVertices;
    }
  }, {
    key: 'mapVertex',
    value: function mapVertex(callback) {
      var vertexNames = Object.keys(this.vertexMap),
          result = vertexNames.map(function (vertexName) {
        var vertex = this.vertexMap[vertexName],
            result = callback(vertex);

        return result;
      }.bind(this));

      return result;
    }
  }, {
    key: 'forEachVertex',
    value: function forEachVertex(callback) {
      var vertexNames = Object.keys(this.vertexMap);

      vertexNames.forEach(function (vertexName) {
        var vertex = this.vertexMap[vertexName];

        callback(vertex);
      }.bind(this));
    }
  }, {
    key: 'fromNothing',
    value: function fromNothing() {
      var vertexMap = {},
          directedAcyclicGraph = new DirectedAcyclicGraph(vertexMap);

      return directedAcyclicGraph;
    }
  }], [{
    key: 'fromTopologicallyOrderedVertices',
    value: function fromTopologicallyOrderedVertices(topologicallyOrderedVertices) {
      var vertexMap = vertexMapFromTopologicallyOrderedVertices(topologicallyOrderedVertices);

      addEdgesToVertices(topologicallyOrderedVertices, vertexMap);

      var directedAcyclicGraph = new DirectedAcyclicGraph(vertexMap);

      return directedAcyclicGraph;
    }
  }, {
    key: 'sortVertices',
    value: function sortVertices(vertices) {
      vertices.sort(function (firstVertex, secondVertex) {
        var firstVertexIndex = firstVertex.getIndex(),
            secondVertexIndex = secondVertex.getIndex();

        if (false) {} else if (firstVertexIndex < secondVertexIndex) {
          return -1;
        } else if (firstVertexIndex > secondVertexIndex) {
          return +1;
        }
      });
    }
  }]);

  return DirectedAcyclicGraph;
}();

module.exports = DirectedAcyclicGraph;

function vertexMapFromTopologicallyOrderedVertices(topologicallyOrderedVertices) {
  var vertexMap = {};

  topologicallyOrderedVertices.forEach(function (topologicallyOrderedVertex, index) {
    var name = topologicallyOrderedVertex.getName(),
        vertex = Vertex.fromNameAndIndex(name, index);

    vertexMap[name] = vertex;
  });

  return vertexMap;
}

function addEdgesToVertices(topologicallyOrderedVertices, vertexMap) {
  topologicallyOrderedVertices.forEach(function (topologicallyOrderedVertex) {
    topologicallyOrderedVertex.forEachOutgoingEdge(function (outgoingEdge) {
      var sourceVertex = outgoingEdge.getSourceVertex(),
          targetVertex = outgoingEdge.getTargetVertex(),
          sourceVertexName = sourceVertex.getName(),
          targetVertexName = targetVertex.getName(),
          immediatePredecessorVertexName = sourceVertexName,
          ///
      immediateSuccessorVertexName = targetVertexName,
          immediatePredecessorVertex = vertexMap[immediatePredecessorVertexName],
          ///
      immediateSuccessorVertex = vertexMap[immediateSuccessorVertexName]; ///

      immediatePredecessorVertex.addImmediateSuccessorVertex(immediateSuccessorVertex);

      immediateSuccessorVertex.addImmediatePredecessorVertex(immediatePredecessorVertex);
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9kaXJlY3RlZEFjeWNsaWNHcmFwaC5qcyJdLCJuYW1lcyI6WyJWZXJ0ZXgiLCJyZXF1aXJlIiwiYXJyYXlVdGlsIiwiRGlyZWN0ZWRBY3ljbGljR3JhcGgiLCJ2ZXJ0ZXhNYXAiLCJ2ZXJ0ZXhOYW1lIiwidmVydGV4UHJlc2VudCIsImhhc093blByb3BlcnR5IiwidmVydGV4TmFtZXMiLCJPYmplY3QiLCJrZXlzIiwidmVydGV4TmFtZXNMZW5ndGgiLCJsZW5ndGgiLCJuYW1lIiwiaW5kZXgiLCJ2ZXJ0ZXgiLCJmcm9tTmFtZUFuZEluZGV4Iiwic291cmNlVmVydGV4TmFtZSIsInRhcmdldFZlcnRleE5hbWUiLCJjeWNsaWNWZXJ0aWNlcyIsImN5Y2xpY1ZlcnRleE5hbWUiLCJjeWNsaWNWZXJ0ZXgiLCJzb3VyY2VWZXJ0ZXgiLCJhZGRWZXJ0ZXhCeVZlcnRleE5hbWUiLCJ0YXJnZXRWZXJ0ZXgiLCJlZGdlUHJlc2VudCIsImlzRWRnZVByZXNlbnRCeVRhcmdldFZlcnRleCIsInNvdXJjZVZlcnRleEluZGV4IiwiZ2V0SW5kZXgiLCJ0YXJnZXRWZXJ0ZXhJbmRleCIsImludmFsaWRhdGluZ0VkZ2UiLCJ2YWxpZGF0ZUVkZ2UiLCJjeWNsZU1pc3NpbmciLCJpbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleCIsImltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleCIsImFkZEltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleCIsImFkZEltbWVkaWF0ZVByZWRlY2Vzc29yVmVydGV4IiwiY3ljbGljVmVydGV4TmFtZXMiLCJmb3JFYWNoIiwiZ2V0TmFtZSIsImVkZ2UiLCJnZXRTb3VyY2VWZXJ0ZXhOYW1lIiwiZ2V0VGFyZ2V0VmVydGV4TmFtZSIsImFkZEVkZ2VCeVZlcnRleE5hbWVzIiwiZm9yd2FyZHNBZmZlY3RlZFZlcnRpY2VzIiwiZ2V0Rm9yd2FyZHNBZmZlY3RlZFZlcnRpY2VzIiwibGFzdEZvcndhcmRzQWZmZWN0ZWRWZXJ0ZXgiLCJsYXN0IiwiY3ljbGVQcmVzZW50IiwiYmFja3dhcmRzQWZmZWN0ZWRWZXJ0aWNlcyIsImdldEJhY2t3YXJkc0FmZmVjdGVkVmVydGljZXMiLCJzb3J0VmVydGljZXMiLCJhZmZlY3RlZFZlcnRpY2VzIiwiY29uY2F0IiwiYWZmZWN0ZWRWZXJ0ZXhJbmRpY2VzIiwibWFwIiwiYWZmZWN0ZWRWZXJ0ZXgiLCJhZmZlY3RlZFZlcnRleEluZGV4Iiwic29ydCIsInNldEluZGV4IiwiY2FsbGJhY2siLCJyZXN1bHQiLCJiaW5kIiwiZGlyZWN0ZWRBY3ljbGljR3JhcGgiLCJ0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzIiwidmVydGV4TWFwRnJvbVRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMiLCJhZGRFZGdlc1RvVmVydGljZXMiLCJ2ZXJ0aWNlcyIsImZpcnN0VmVydGV4Iiwic2Vjb25kVmVydGV4IiwiZmlyc3RWZXJ0ZXhJbmRleCIsInNlY29uZFZlcnRleEluZGV4IiwibW9kdWxlIiwiZXhwb3J0cyIsInRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4IiwiZm9yRWFjaE91dGdvaW5nRWRnZSIsIm91dGdvaW5nRWRnZSIsImdldFNvdXJjZVZlcnRleCIsImdldFRhcmdldFZlcnRleCIsImltbWVkaWF0ZVByZWRlY2Vzc29yVmVydGV4TmFtZSIsImltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleE5hbWUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFFQSxJQUFNQSxTQUFTQyxRQUFRLFVBQVIsQ0FBZjtBQUFBLElBQ01DLFlBQVlELFFBQVEsY0FBUixDQURsQjs7SUFHTUUsb0I7QUFDSixnQ0FBWUMsU0FBWixFQUF1QjtBQUFBOztBQUNyQixTQUFLQSxTQUFMLEdBQWlCQSxTQUFqQjtBQUNEOzs7OzBDQUVxQkMsVSxFQUFZO0FBQ2hDLFVBQU1DLGdCQUFnQixLQUFLRixTQUFMLENBQWVHLGNBQWYsQ0FBOEJGLFVBQTlCLENBQXRCOztBQUVBLFVBQUksQ0FBQ0MsYUFBTCxFQUFvQjtBQUNsQixZQUFNRSxjQUFjQyxPQUFPQyxJ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UyxJQUFWLElBQWtCRSxNQUFsQjtBQUNELEdBTEQ7O0FBT0EsU0FBT1gsU0FBUDtBQUNEOztBQUVELFNBQVM4RCxrQkFBVCxDQUE0QkYsNEJBQTVCLEVBQTBENUQsU0FBMUQsRUFBcUU7QUFDbkU0RCwrQkFBNkIxQixPQUE3QixDQUFxQyxVQUFTb0MsMEJBQVQsRUFBcUM7QUFDeEVBLCtCQUEyQkMsbUJBQTNCLENBQStDLFVBQVNDLFlBQVQsRUFBdUI7QUFDcEUsVUFBTXRELGVBQWVzRCxhQUFhQyxlQUFiLEVBQXJCO0FBQUEsVUFDTXJELGVBQWVvRCxhQUFhRSxlQUFiLEVBRHJCO0FBQUEsVUFFTTdELG1CQUFtQkssYUFBYWlCLE9BQWIsRUFGekI7QUFBQSxVQUdNckIsbUJBQW1CTSxhQUFhZSxPQUFiLEVBSHpCO0FBQUEsVUFJTXdDLGlDQUFpQzlELGdCQUp2QztBQUFBLFVBSTBEO0FBQ3BEK0QscUNBQStCOUQsZ0JBTHJDO0FBQUEsVUFNTWUsNkJBQTZCN0IsVUFBVTJFLDhCQUFWLENBTm5DO0FBQUEsVUFNOEU7QUFDeEU3QyxpQ0FBMkI5QixVQUFVNEUsNEJBQVYsQ0FQakMsQ0FEb0UsQ0FRTTs7QUFFMUUvQyxpQ0FBMkJFLDJCQUEzQixDQUF1REQsd0JBQXZEOztBQUVBQSwrQkFBeUJFLDZCQUF6QixDQUF1REgsMEJBQXZEO0FBQ0QsS0FiRDtBQWNELEdBZkQ7QUFnQkQiLCJmaWxlIjoiZGlyZWN0ZWRBY3ljbGljR3JhcGguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFZlcnRleCA9IHJlcXVpcmUoJy4vdmVydGV4JyksXG4gICAgICBhcnJheVV0aWwgPSByZXF1aXJlKCcuL3V0aWwvYXJyYXknKTtcblxuY2xhc3MgRGlyZWN0ZWRBY3ljbGljR3JhcGgge1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhNYXApIHtcbiAgICB0aGlzLnZlcnRleE1hcCA9IHZlcnRleE1hcDtcbiAgfVxuXG4gIGFkZFZlcnRleEJ5VmVydGV4TmFtZSh2ZXJ0ZXhOYW1lKSB7XG4gICAgY29uc3QgdmVydGV4UHJlc2VudCA9IHRoaXMudmVydGV4TWFwLmhhc093blByb3BlcnR5KHZlcnRleE5hbWUpO1xuXG4gICAgaWYgKCF2ZXJ0ZXhQcmVzZW50KSB7XG4gICAgICBjb25zdCB2ZXJ0ZXhOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMudmVydGV4TWFwKSxcbiAgICAgICAgICAgIHZlcnRleE5hbWVzTGVuZ3RoID0gdmVydGV4TmFtZXMubGVuZ3RoLFxuICAgICAgICAgICAgbmFtZSA9IHZlcnRleE5hbWUsICAvLy9cbiAgICAgICAgICAgIGluZGV4ID0gdmVydGV4TmFtZXNMZW5ndGgsIC8vL1xuICAgICAgICAgICAgdmVydGV4ID0gVmVydGV4LmZyb21OYW1lQW5kSW5kZXgobmFtZSwgaW5kZXgpO1xuXG4gICAgICB0aGlzLnZlcnRleE1hcFt2ZXJ0ZXhOYW1lXSA9IHZlcnRleDtcbiAgICB9XG5cbiAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLnZlcnRleE1hcFt2ZXJ0ZXhOYW1lXTtcblxuICAgIHJldHVybiB2ZXJ0ZXg7XG4gIH1cblxuICBhZGRFZGdlQnlWZXJ0ZXhOYW1lcyhzb3VyY2VWZXJ0ZXhOYW1lLCB0YXJnZXRWZXJ0ZXhOYW1lKSB7XG4gICAgbGV0IGN5Y2xpY1ZlcnRpY2VzID0gbnVsbDtcblxuICAgIGlmIChzb3VyY2VWZXJ0ZXhOYW1lID09PSB0YXJnZXRWZXJ0ZXhOYW1lKSB7XG4gICAgICBjb25zdCBjeWNsaWNWZXJ0ZXhOYW1lID0gc291cmNlVmVydGV4TmFtZSwgIC8vL1xuICAgICAgICAgICAgY3ljbGljVmVydGV4ID0gdGhpcy52ZXJ0ZXhNYXBbY3ljbGljVmVydGV4TmFtZV07XG5cbiAgICAgIGN5Y2xpY1ZlcnRpY2VzID0gW2N5Y2xpY1ZlcnRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IHRoaXMuYWRkVmVydGV4QnlWZXJ0ZXhOYW1lKHNvdXJjZVZlcnRleE5hbWUpLFxuICAgICAgICAgICAgdGFyZ2V0VmVydGV4ID0gdGhpcy5hZGRWZXJ0ZXhCeVZlcnRleE5hbWUodGFyZ2V0VmVydGV4TmFtZSksXG4gICAgICAgICAgICBlZGdlUHJlc2VudCA9IHNvdXJjZVZlcnRleC5pc0VkZ2VQcmVzZW50QnlUYXJnZXRWZXJ0ZXgodGFyZ2V0VmVydGV4KTtcblxuICAgICAgaWYgKCFlZGdlUHJlc2VudCkge1xuICAgICAgICBjb25zdCBzb3VyY2VWZXJ0ZXhJbmRleCA9IHNvdXJjZVZlcnRleC5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICB0YXJnZXRWZXJ0ZXhJbmRleCA9IHRhcmdldFZlcnRleC5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICBpbnZhbGlkYXRpbmdFZGdlID0gKHNvdXJjZVZlcnRleEluZGV4ID4gdGFyZ2V0VmVydGV4SW5kZXgpO1xuXG4gICAgICAgIGlmIChpbnZhbGlkYXRpbmdFZGdlKSB7XG4gICAgICAgICAgY3ljbGljVmVydGljZXMgPSB0aGlzLnZhbGlkYXRlRWRnZShzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjeWNsZU1pc3NpbmcgPSAoY3ljbGljVmVydGljZXMgPT09IG51bGwpOyAvLy9cblxuICAgICAgICBpZiAoY3ljbGVNaXNzaW5nKSB7XG4gICAgICAgICAgY29uc3QgaW1tZWRpYXRlUHJlZGVjZXNzb3JWZXJ0ZXggPSBzb3VyY2VWZXJ0ZXgsIC8vL1xuICAgICAgICAgICAgICAgIGltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleCA9IHRhcmdldFZlcnRleDsgLy8vXG5cbiAgICAgICAgICBpbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleC5hZGRJbW1lZGlhdGVTdWNjZXNzb3JWZXJ0ZXgoaW1tZWRpYXRlU3VjY2Vzc29yVmVydGV4KTtcblxuICAgICAgICAgIGltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleC5hZGRJbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleChpbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY3ljbGljVmVydGV4TmFtZXM7XG5cbiAgICBpZiAoY3ljbGljVmVydGljZXMgIT09IG51bGwpIHtcbiAgICAgIGN5Y2xpY1ZlcnRleE5hbWVzID0gY3ljbGljVmVydGljZXMuZm9yRWFjaChmdW5jdGlvbihjeWNsaWNWZXJ0ZXgpIHtcbiAgICAgICAgY29uc3QgY3ljbGljVmVydGV4TmFtZSA9IGN5Y2xpY1ZlcnRleC5nZXROYW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIGN5Y2xpY1ZlcnRleE5hbWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3ljbGljVmVydGV4TmFtZXM7XG4gIH1cbiAgXG4gIGFkZEVkZ2UoZWRnZSkge1xuICAgIGNvbnN0IHNvdXJjZVZlcnRleE5hbWUgPSBlZGdlLmdldFNvdXJjZVZlcnRleE5hbWUoKSxcbiAgICAgICAgICB0YXJnZXRWZXJ0ZXhOYW1lID0gZWRnZS5nZXRUYXJnZXRWZXJ0ZXhOYW1lKCk7XG4gICAgXG4gICAgdGhpcy5hZGRFZGdlQnlWZXJ0ZXhOYW1lcyhzb3VyY2VWZXJ0ZXhOYW1lLCB0YXJnZXRWZXJ0ZXhOYW1lKTtcbiAgfVxuXG4gIHZhbGlkYXRlRWRnZShzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCkge1xuICAgIGxldCBjeWNsaWNWZXJ0aWNlcyA9IG51bGw7XG5cbiAgICBjb25zdCBmb3J3YXJkc0FmZmVjdGVkVmVydGljZXMgPSB0YXJnZXRWZXJ0ZXguZ2V0Rm9yd2FyZHNBZmZlY3RlZFZlcnRpY2VzKHNvdXJjZVZlcnRleCksXG4gICAgICAgICAgbGFzdEZvcndhcmRzQWZmZWN0ZWRWZXJ0ZXggPSBhcnJheVV0aWwubGFzdChmb3J3YXJkc0FmZmVjdGVkVmVydGljZXMpLFxuICAgICAgICAgIGN5Y2xlUHJlc2VudCA9IChsYXN0Rm9yd2FyZHNBZmZlY3RlZFZlcnRleCA9PT0gc291cmNlVmVydGV4KTtcbiAgICBcbiAgICBpZiAoY3ljbGVQcmVzZW50KSB7XG4gICAgICBjeWNsaWNWZXJ0aWNlcyA9IGZvcndhcmRzQWZmZWN0ZWRWZXJ0aWNlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFja3dhcmRzQWZmZWN0ZWRWZXJ0aWNlcyA9IHNvdXJjZVZlcnRleC5nZXRCYWNrd2FyZHNBZmZlY3RlZFZlcnRpY2VzKCk7XG5cbiAgICAgIERpcmVjdGVkQWN5Y2xpY0dyYXBoLnNvcnRWZXJ0aWNlcyhiYWNrd2FyZHNBZmZlY3RlZFZlcnRpY2VzKTtcblxuICAgICAgRGlyZWN0ZWRBY3ljbGljR3JhcGguc29ydFZlcnRpY2VzKGZvcndhcmRzQWZmZWN0ZWRWZXJ0aWNlcyk7XG5cbiAgICAgIGNvbnN0IGFmZmVjdGVkVmVydGljZXMgPSBbXS5jb25jYXQoYmFja3dhcmRzQWZmZWN0ZWRWZXJ0aWNlcykuY29uY2F0KGZvcndhcmRzQWZmZWN0ZWRWZXJ0aWNlcyksXG4gICAgICAgICAgICBhZmZlY3RlZFZlcnRleEluZGljZXMgPSBhZmZlY3RlZFZlcnRpY2VzLm1hcChmdW5jdGlvbihhZmZlY3RlZFZlcnRleCkge1xuICAgICAgICAgICAgICBjb25zdCBhZmZlY3RlZFZlcnRleEluZGV4ID0gYWZmZWN0ZWRWZXJ0ZXguZ2V0SW5kZXgoKTtcblxuICAgICAgICAgICAgICByZXR1cm4gYWZmZWN0ZWRWZXJ0ZXhJbmRleDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICBhZmZlY3RlZFZlcnRleEluZGljZXMuc29ydCgpO1xuXG4gICAgICBhZmZlY3RlZFZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24oYWZmZWN0ZWRWZXJ0ZXgsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGFmZmVjdGVkVmVydGV4SW5kZXggPSBhZmZlY3RlZFZlcnRleEluZGljZXNbaW5kZXhdO1xuXG4gICAgICAgIGFmZmVjdGVkVmVydGV4LnNldEluZGV4KGFmZmVjdGVkVmVydGV4SW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN5Y2xpY1ZlcnRpY2VzO1xuICB9XG5cbiAgbWFwVmVydGV4KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdmVydGV4TmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnZlcnRleE1hcCksXG4gICAgICAgICAgcmVzdWx0ID0gdmVydGV4TmFtZXMubWFwKGZ1bmN0aW9uKHZlcnRleE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRleCA9IHRoaXMudmVydGV4TWFwW3ZlcnRleE5hbWVdLFxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodmVydGV4KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmb3JFYWNoVmVydGV4KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdmVydGV4TmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnZlcnRleE1hcCk7XG5cbiAgICB2ZXJ0ZXhOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleE5hbWUpIHtcbiAgICAgIGNvbnN0IHZlcnRleCA9IHRoaXMudmVydGV4TWFwW3ZlcnRleE5hbWVdO1xuXG4gICAgICBjYWxsYmFjayh2ZXJ0ZXgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cbiAgXG4gIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHZlcnRleE1hcCA9IHt9LFxuICAgICAgICAgIGRpcmVjdGVkQWN5Y2xpY0dyYXBoID0gbmV3IERpcmVjdGVkQWN5Y2xpY0dyYXBoKHZlcnRleE1hcCk7XG5cbiAgICByZXR1cm4gZGlyZWN0ZWRBY3ljbGljR3JhcGg7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXModG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcykge1xuICAgIGNvbnN0IHZlcnRleE1hcCA9IHZlcnRleE1hcEZyb21Ub3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzKHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMpO1xuICAgIFxuICAgIGFkZEVkZ2VzVG9WZXJ0aWNlcyh0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzLCB2ZXJ0ZXhNYXApO1xuICAgIFxuICAgIGNvbnN0IGRpcmVjdGVkQWN5Y2xpY0dyYXBoID0gbmV3IERpcmVjdGVkQWN5Y2xpY0dyYXBoKHZlcnRleE1hcCk7XG4gICAgXG4gICAgcmV0dXJuIGRpcmVjdGVkQWN5Y2xpY0dyYXBoO1xuICB9XG5cbiAgc3RhdGljIHNvcnRWZXJ0aWNlcyh2ZXJ0aWNlcykge1xuICAgIHZlcnRpY2VzLnNvcnQoZnVuY3Rpb24oZmlyc3RWZXJ0ZXgsIHNlY29uZFZlcnRleCkge1xuICAgICAgY29uc3QgZmlyc3RWZXJ0ZXhJbmRleCA9IGZpcnN0VmVydGV4LmdldEluZGV4KCksXG4gICAgICAgICAgICBzZWNvbmRWZXJ0ZXhJbmRleCA9IHNlY29uZFZlcnRleC5nZXRJbmRleCgpO1xuXG4gICAgICBpZiAoZmFsc2UpIHtcblxuICAgICAgfSBlbHNlICBpZiAoZmlyc3RWZXJ0ZXhJbmRleCA8IHNlY29uZFZlcnRleEluZGV4KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSAgaWYgKGZpcnN0VmVydGV4SW5kZXggPiBzZWNvbmRWZXJ0ZXhJbmRleCkge1xuICAgICAgICByZXR1cm4gKzE7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaXJlY3RlZEFjeWNsaWNHcmFwaDtcblxuZnVuY3Rpb24gdmVydGV4TWFwRnJvbVRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXModG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcykge1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcbiAgXG4gIHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMuZm9yRWFjaChmdW5jdGlvbih0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleCwgaW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXguZ2V0TmFtZSgpLFxuICAgICAgICAgIHZlcnRleCA9IFZlcnRleC5mcm9tTmFtZUFuZEluZGV4KG5hbWUsIGluZGV4KTtcblxuICAgIHZlcnRleE1hcFtuYW1lXSA9IHZlcnRleDtcbiAgfSk7XG5cbiAgcmV0dXJuIHZlcnRleE1hcDtcbn1cblxuZnVuY3Rpb24gYWRkRWRnZXNUb1ZlcnRpY2VzKHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMsIHZlcnRleE1hcCkge1xuICB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24odG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXgpIHtcbiAgICB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleC5mb3JFYWNoT3V0Z29pbmdFZGdlKGZ1bmN0aW9uKG91dGdvaW5nRWRnZSkge1xuICAgICAgY29uc3Qgc291cmNlVmVydGV4ID0gb3V0Z29pbmdFZGdlLmdldFNvdXJjZVZlcnRleCgpLFxuICAgICAgICAgICAgdGFyZ2V0VmVydGV4ID0gb3V0Z29pbmdFZGdlLmdldFRhcmdldFZlcnRleCgpLFxuICAgICAgICAgICAgc291cmNlVmVydGV4TmFtZSA9IHNvdXJjZVZlcnRleC5nZXROYW1lKCksXG4gICAgICAgICAgICB0YXJnZXRWZXJ0ZXhOYW1lID0gdGFyZ2V0VmVydGV4LmdldE5hbWUoKSxcbiAgICAgICAgICAgIGltbWVkaWF0ZVByZWRlY2Vzc29yVmVydGV4TmFtZSA9IHNvdXJjZVZlcnRleE5hbWUsICAvLy9cbiAgICAgICAgICAgIGltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleE5hbWUgPSB0YXJnZXRWZXJ0ZXhOYW1lLFxuICAgICAgICAgICAgaW1tZWRpYXRlUHJlZGVjZXNzb3JWZXJ0ZXggPSB2ZXJ0ZXhNYXBbaW1tZWRpYXRlUHJlZGVjZXNzb3JWZXJ0ZXhOYW1lXSwgLy8vXG4gICAgICAgICAgICBpbW1lZGlhdGVTdWNjZXNzb3JWZXJ0ZXggPSB2ZXJ0ZXhNYXBbaW1tZWRpYXRlU3VjY2Vzc29yVmVydGV4TmFtZV07IC8vL1xuXG4gICAgICBpbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleC5hZGRJbW1lZGlhdGVTdWNjZXNzb3JWZXJ0ZXgoaW1tZWRpYXRlU3VjY2Vzc29yVmVydGV4KTtcblxuICAgICAgaW1tZWRpYXRlU3VjY2Vzc29yVmVydGV4LmFkZEltbWVkaWF0ZVByZWRlY2Vzc29yVmVydGV4KGltbWVkaWF0ZVByZWRlY2Vzc29yVmVydGV4KTtcbiAgICB9KTtcbiAgfSk7XG59XG4iXX0=