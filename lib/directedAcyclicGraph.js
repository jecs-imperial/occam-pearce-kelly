'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Vertex = require('./vertex'),
    arrayUtil = require('./util/array');

var DirectedAcyclicGraph = function () {
  function DirectedAcyclicGraph(vertexMap) {
    _classCallCheck(this, DirectedAcyclicGraph);

    this.vertexMap = vertexMap;
  }

  _createClass(DirectedAcyclicGraph, [{
    key: 'addVertexByVertexName',
    value: function addVertexByVertexName(vertexName) {
      var vertexPresent = this.vertexMap.hasOwnProperty(vertexName);

      if (!vertexPresent) {
        var vertexNames = Object.keys(this.vertexMap),
            vertexNamesLength = vertexNames.length,
            name = vertexName,
            ///
        index = vertexNamesLength,
            ///
        _vertex = Vertex.fromNameAndIndex(name, index);

        this.vertexMap[vertexName] = _vertex;
      }

      var vertex = this.vertexMap[vertexName];

      return vertex;
    }
  }, {
    key: 'addEdgeByVertexNames',
    value: function addEdgeByVertexNames(sourceVertexName, targetVertexName) {
      var cyclicVertices = null;

      if (sourceVertexName === targetVertexName) {
        var cyclicVertexName = sourceVertexName,
            ///
        cyclicVertex = this.vertexMap[cyclicVertexName];

        cyclicVertices = [cyclicVertex];
      } else {
        var sourceVertex = this.addVertexByVertexName(sourceVertexName),
            targetVertex = this.addVertexByVertexName(targetVertexName),
            edgePresent = sourceVertex.isEdgePresentByTargetVertex(targetVertex);

        if (!edgePresent) {
          var sourceVertexIndex = sourceVertex.getIndex(),
              targetVertexIndex = targetVertex.getIndex(),
              invalidatingEdge = sourceVertexIndex > targetVertexIndex;

          if (invalidatingEdge) {
            cyclicVertices = this.validateEdge(sourceVertex, targetVertex);
          }

          var cycleMissing = cyclicVertices === null; ///

          if (cycleMissing) {
            var immediatePredecessorVertex = sourceVertex,
                ///
            immediateSuccessorVertex = targetVertex; ///

            immediatePredecessorVertex.addImmediateSuccessorVertex(immediateSuccessorVertex);

            immediateSuccessorVertex.addImmediatePredecessorVertex(immediatePredecessorVertex);
          }
        }
      }

      var cyclicVertexNames = void 0;

      if (cyclicVertices !== null) {
        cyclicVertexNames = cyclicVertices.forEach(function (cyclicVertex) {
          var cyclicVertexName = cyclicVertex.getName();

          return cyclicVertexName;
        });
      }

      return cyclicVertexNames;
    }
  }, {
    key: 'validateEdge',
    value: function validateEdge(sourceVertex, targetVertex) {
      var cyclicVertices = null;

      var forwardsAffectedVertices = targetVertex.getForwardsAffectedVertices(sourceVertex),
          lastForwardsAffectedVertex = arrayUtil.last(forwardsAffectedVertices),
          cyclePresent = lastForwardsAffectedVertex === sourceVertex;

      if (cyclePresent) {
        cyclicVertices = forwardsAffectedVertices;
      } else {
        var backwardsAffectedVertices = sourceVertex.getBackwardsAffectedVertices();

        DirectedAcyclicGraph.sortVertices(backwardsAffectedVertices);

        DirectedAcyclicGraph.sortVertices(forwardsAffectedVertices);

        var affectedVertices = [].concat(backwardsAffectedVertices).concat(forwardsAffectedVertices),
            affectedVertexIndices = affectedVertices.map(function (affectedVertex) {
          var affectedVertexIndex = affectedVertex.getIndex();

          return affectedVertexIndex;
        });

        affectedVertexIndices.sort();

        affectedVertices.forEach(function (affectedVertex, index) {
          var affectedVertexIndex = affectedVertexIndices[index];

          affectedVertex.setIndex(affectedVertexIndex);
        });
      }

      return cyclicVertices;
    }
  }, {
    key: 'mapVertex',
    value: function mapVertex(callback) {
      var vertexNames = Object.keys(this.vertexMap),
          result = vertexNames.map(function (vertexName) {
        var vertex = this.vertexMap[vertexName],
            result = callback(vertex);

        return result;
      }.bind(this));

      return result;
    }
  }, {
    key: 'forEachVertex',
    value: function forEachVertex(callback) {
      var vertexNames = Object.keys(this.vertexMap);

      vertexNames.forEach(function (vertexName) {
        var vertex = this.vertexMap[vertexName];

        callback(vertex);
      }.bind(this));
    }
  }], [{
    key: 'fromTopologicallyOrderedVertices',
    value: function fromTopologicallyOrderedVertices(topologicallyOrderedVertices) {
      var vertexMap = vertexMapFromTopologicallyOrderedVertices(topologicallyOrderedVertices);

      addEdgesToVertices(topologicallyOrderedVertices, vertexMap);

      var directedAcyclicGraph = new DirectedAcyclicGraph(vertexMap);

      return directedAcyclicGraph;
    }
  }, {
    key: 'sortVertices',
    value: function sortVertices(vertices) {
      vertices.sort(function (firstVertex, secondVertex) {
        var firstVertexIndex = firstVertex.getIndex(),
            secondVertexIndex = secondVertex.getIndex();

        if (false) {} else if (firstVertexIndex < secondVertexIndex) {
          return -1;
        } else if (firstVertexIndex > secondVertexIndex) {
          return +1;
        }
      });
    }
  }]);

  return DirectedAcyclicGraph;
}();

module.exports = DirectedAcyclicGraph;

function vertexMapFromTopologicallyOrderedVertices(topologicallyOrderedVertices) {
  var vertexMap = {};

  topologicallyOrderedVertices.forEach(function (topologicallyOrderedVertex, index) {
    var name = topologicallyOrderedVertex.getName(),
        vertex = Vertex.fromNameAndIndex(name, index);

    vertexMap[name] = vertex;
  });

  return vertexMap;
}

function addEdgesToVertices(topologicallyOrderedVertices, vertexMap) {
  topologicallyOrderedVertices.forEach(function (topologicallyOrderedVertex) {
    topologicallyOrderedVertex.forEachOutgoingEdge(function (outgoingEdge) {
      var sourceVertex = outgoingEdge.getSourceVertex(),
          targetVertex = outgoingEdge.getTargetVertex(),
          sourceVertexName = sourceVertex.getName(),
          targetVertexName = targetVertex.getName(),
          immediatePredecessorVertexName = sourceVertexName,
          ///
      immediateSuccessorVertexName = targetVertexName,
          immediatePredecessorVertex = vertexMap[immediatePredecessorVertexName],
          ///
      immediateSuccessorVertex = vertexMap[immediateSuccessorVertexName]; ///

      immediatePredecessorVertex.addImmediateSuccessorVertex(immediateSuccessorVertex);

      immediateSuccessorVertex.addImmediatePredecessorVertex(immediatePredecessorVertex);
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9kaXJlY3RlZEFjeWNsaWNHcmFwaC5qcyJdLCJuYW1lcyI6WyJWZXJ0ZXgiLCJyZXF1aXJlIiwiYXJyYXlVdGlsIiwiRGlyZWN0ZWRBY3ljbGljR3JhcGgiLCJ2ZXJ0ZXhNYXAiLCJ2ZXJ0ZXhOYW1lIiwidmVydGV4UHJlc2VudCIsImhhc093blByb3BlcnR5IiwidmVydGV4TmFtZXMiLCJPYmplY3QiLCJrZXlzIiwidmVydGV4TmFtZXNMZW5ndGgiLCJsZW5ndGgiLCJuYW1lIiwiaW5kZXgiLCJ2ZXJ0ZXgiLCJmcm9tTmFtZUFuZEluZGV4Iiwic291cmNlVmVydGV4TmFtZSIsInRhcmdldFZlcnRleE5hbWUiLCJjeWNsaWNWZXJ0aWNlcyIsImN5Y2xpY1ZlcnRleE5hbWUiLCJjeWNsaWNWZXJ0ZXgiLCJzb3VyY2VWZXJ0ZXgiLCJhZGRWZXJ0ZXhCeVZlcnRleE5hbWUiLCJ0YXJnZXRWZXJ0ZXgiLCJlZGdlUHJlc2VudCIsImlzRWRnZVByZXNlbnRCeVRhcmdldFZlcnRleCIsInNvdXJjZVZlcnRleEluZGV4IiwiZ2V0SW5kZXgiLCJ0YXJnZXRWZXJ0ZXhJbmRleCIsImludmFsaWRhdGluZ0VkZ2UiLCJ2YWxpZGF0ZUVkZ2UiLCJjeWNsZU1pc3NpbmciLCJpbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleCIsImltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleCIsImFkZEltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleCIsImFkZEltbWVkaWF0ZVByZWRlY2Vzc29yVmVydGV4IiwiY3ljbGljVmVydGV4TmFtZXMiLCJmb3JFYWNoIiwiZ2V0TmFtZSIsImZvcndhcmRzQWZmZWN0ZWRWZXJ0aWNlcyIsImdldEZvcndhcmRzQWZmZWN0ZWRWZXJ0aWNlcyIsImxhc3RGb3J3YXJkc0FmZmVjdGVkVmVydGV4IiwibGFzdCIsImN5Y2xlUHJlc2VudCIsImJhY2t3YXJkc0FmZmVjdGVkVmVydGljZXMiLCJnZXRCYWNrd2FyZHNBZmZlY3RlZFZlcnRpY2VzIiwic29ydFZlcnRpY2VzIiwiYWZmZWN0ZWRWZXJ0aWNlcyIsImNvbmNhdCIsImFmZmVjdGVkVmVydGV4SW5kaWNlcyIsIm1hcCIsImFmZmVjdGVkVmVydGV4IiwiYWZmZWN0ZWRWZXJ0ZXhJbmRleCIsInNvcnQiLCJzZXRJbmRleCIsImNhbGxiYWNrIiwicmVzdWx0IiwiYmluZCIsInRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMiLCJ2ZXJ0ZXhNYXBGcm9tVG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcyIsImFkZEVkZ2VzVG9WZXJ0aWNlcyIsImRpcmVjdGVkQWN5Y2xpY0dyYXBoIiwidmVydGljZXMiLCJmaXJzdFZlcnRleCIsInNlY29uZFZlcnRleCIsImZpcnN0VmVydGV4SW5kZXgiLCJzZWNvbmRWZXJ0ZXhJbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleCIsImZvckVhY2hPdXRnb2luZ0VkZ2UiLCJvdXRnb2luZ0VkZ2UiLCJnZXRTb3VyY2VWZXJ0ZXgiLCJnZXRUYXJnZXRWZXJ0ZXgiLCJpbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleE5hbWUiLCJpbW1lZGlhdGVTdWNjZXNzb3JWZXJ0ZXhOYW1lIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBRUEsSUFBTUEsU0FBU0MsUUFBUSxVQUFSLENBQWY7QUFBQSxJQUNNQyxZQUFZRCxRQUFRLGNBQVIsQ0FEbEI7O0lBR01FLG9CO0FBQ0osZ0NBQVlDLFNBQVosRUFBdUI7QUFBQTs7QUFDckIsU0FBS0EsU0FBTCxHQUFpQkEsU0FBakI7QUFDRDs7OzswQ0FFcUJDLFUsRUFBWTtBQUNoQyxVQUFNQyxnQkFBZ0IsS0FBS0YsU0FBTCxDQUFlRyxjQUFmLENBQThCRixVQUE5QixDQUF0Qjs7QUFFQSxVQUFJLENBQUNDLGFBQUwsRUFBb0I7QUFDbEIsWUFBTUUsY0FBY0MsT0FBT0MsSUFBUCxDQUFZLEtBQUtOLFNBQWpCLENBQXBCO0FBQUEsWUFDTU8sb0JBQW9CSCxZQUFZSSxNQUR0QztBQUFBLFlBRU1DLE9BQU9SLFVBRmI7QUFBQSxZQUUwQjtBQUNwQlMsZ0JBQVFILGlCQUhkO0FBQUEsWUFHaUM7QUFDM0JJLGtCQUFTZixPQUFPZ0IsZ0JBQVAsQ0FBd0JILElBQXhCLEVBQThCQyxLQUE5QixDQUpmOztBQU1BLGFBQUtWLFNBQUwsQ0FBZUMsVUFBZixJQUE2QlUsT0FBN0I7QUFDRDs7QUFFRCxVQUFNQSxTQUFTLEtBQUtYLFNBQUwsQ0FBZUMsVUFBZixDQUFmOztBQUVBLGFBQU9VLE1BQVA7QUFDRDs7O3lDQUVvQkUsZ0IsRUFBa0JDLGdCLEVBQWtCO0FBQ3ZELFVBQUlDLGlCQUFpQixJQUFyQjs7QUFFQSxVQUFJRixxQkFBcUJDLGdCQUF6QixFQUEyQztBQUN6QyxZQUFNRSxtQkFBbUJILGdCQUF6QjtBQUFBLFlBQTRDO0FBQ3RDSSx1QkFBZSxLQUFLakIsU0FBTCxDQUFlZ0IsZ0JBQWYsQ0FEckI7O0FBR0FELHlCQUFpQixDQUFDRSxZQUFELENBQWpCO0FBQ0QsT0FMRCxNQUtPO0FBQ0wsWUFBTUMsZUFBZSxLQUFLQyxxQkFBTCxDQUEyQk4sZ0JBQTNCLENBQXJCO0FBQUEsWUFDTU8sZUFBZSxLQUFLRCxxQkFBTCxDQUEyQkwsZ0JBQTNCLENBRHJCO0FBQUEsWUFFTU8sY0FBY0gsYUFBYUksMkJBQWIsQ0FBeUNGLFlBQXpDLENBRnBCOztBQUlBLFlBQUksQ0FBQ0MsV0FBTCxFQUFrQjtBQUNoQixjQUFNRSxvQkFBb0JMLGFBQWFNLFFBQWIsRUFBMUI7QUFBQSxjQUNNQyxvQkFBb0JMLGFBQWFJLFFBQWIsRUFEMUI7QUFBQSxjQUVNRSxtQkFBb0JILG9CQUFvQkUsaUJBRjlDOztBQUlBLGNBQUlDLGdCQUFKLEVBQXNCO0FBQ3BCWCw2QkFBaUIsS0FBS1ksWUFBTCxDQUFrQlQsWUFBbEIsRUFBZ0NFLFlBQWhDLENBQWpCO0FBQ0Q7O0FBRUQsY0FBTVEsZUFBZ0JiLG1CQUFtQixJQUF6QyxDQVRnQixDQVNnQzs7QUFFaEQsY0FBSWEsWUFBSixFQUFrQjtBQUNoQixnQkFBTUMsNkJBQTZCWCxZQUFuQztBQUFBLGdCQUFpRDtBQUMzQ1ksdUNBQTJCVixZQURqQyxDQURnQixDQUUrQjs7QUFFL0NTLHVDQUEyQkUsMkJBQTNCLENBQXVERCx3QkFBdkQ7O0FBRUFBLHFDQUF5QkUsNkJBQXpCLENBQXVESCwwQkFBdkQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsVUFBSUksMEJBQUo7O0FBRUEsVUFBSWxCLG1CQUFtQixJQUF2QixFQUE2QjtBQUMzQmtCLDRCQUFvQmxCLGVBQWVtQixPQUFmLENBQXVCLFVBQVNqQixZQUFULEVBQXVCO0FBQ2hFLGNBQU1ELG1CQUFtQkMsYUFBYWtCLE9BQWIsRUFBekI7O0FBRUEsaUJBQU9uQixnQkFBUDtBQUNELFNBSm1CLENBQXBCO0FBS0Q7O0FBRUQsYUFBT2lCLGlCQUFQO0FBQ0Q7OztpQ0FFWWYsWSxFQUFjRSxZLEVBQWM7QUFDdkMsVUFBSUwsaUJBQWlCLElBQXJCOztBQUVBLFVBQU1xQiwyQkFBMkJoQixhQUFhaUIsMkJBQWIsQ0FBeUNuQixZQUF6QyxDQUFqQztBQUFBLFVBQ01vQiw2QkFBNkJ4QyxVQUFVeUMsSUFBVixDQUFlSCx3QkFBZixDQURuQztBQUFBLFVBRU1JLGVBQWdCRiwrQkFBK0JwQixZQUZyRDs7QUFJQSxVQUFJc0IsWUFBSixFQUFrQjtBQUNoQnpCLHlCQUFpQnFCLHdCQUFqQjtBQUNELE9BRkQsTUFFTztBQUNMLFlBQU1LLDRCQUE0QnZCLGFBQWF3Qiw0QkFBYixFQUFsQzs7QUFFQTNDLDZCQUFxQjRDLFlBQXJCLENBQWtDRix5QkFBbEM7O0FBRUExQyw2QkFBcUI0QyxZQUFyQixDQUFrQ1Asd0JBQWxDOztBQUVBLFlBQU1RLG1CQUFtQixHQUFHQyxNQUFILENBQVVKLHlCQUFWLEVBQXFDSSxNQUFyQyxDQUE0Q1Qsd0JBQTVDLENBQXpCO0FBQUEsWUFDTVUsd0JBQXdCRixpQkFBaUJHLEdBQWpCLENBQXFCLFVBQVNDLGNBQVQsRUFBeUI7QUFDcEUsY0FBTUMsc0JBQXNCRCxlQUFleEIsUUFBZixFQUE1Qjs7QUFFQSxpQkFBT3lCLG1CQUFQO0FBQ0QsU0FKdUIsQ0FEOUI7O0FBT0FILDhCQUFzQkksSUFBdEI7O0FBRUFOLHlCQUFpQlYsT0FBakIsQ0FBeUIsVUFBU2MsY0FBVCxFQUF5QnRDLEtBQXpCLEVBQWdDO0FBQ3ZELGNBQU11QyxzQkFBc0JILHNCQUFzQnBDLEtBQXRCLENBQTVCOztBQUVBc0MseUJBQWVHLFFBQWYsQ0FBd0JGLG1CQUF4QjtBQUNELFNBSkQ7QUFLRDs7QUFFRCxhQUFPbEMsY0FBUDtBQUNEOzs7OEJBRVNxQyxRLEVBQVU7QUFDbEIsVUFBTWhELGNBQWNDLE9BQU9DLElBQVAsQ0FBWSxLQUFLTixTQUFqQixDQUFwQjtBQUFBLFVBQ01xRCxTQUFTakQsWUFBWTJDLEdBQVosQ0FBZ0IsVUFBUzlDLFVBQVQsRUFBcUI7QUFDNUMsWUFBTVUsU0FBUyxLQUFLWCxTQUFMLENBQWVDLFVBQWYsQ0FBZjtBQUFBLFlBQ01vRCxTQUFTRCxTQUFTekMsTUFBVCxDQURmOztBQUdBLGVBQU8wQyxNQUFQO0FBQ0QsT0FMd0IsQ0FLdkJDLElBTHVCLENBS2xCLElBTGtCLENBQWhCLENBRGY7O0FBUUEsYUFBT0QsTUFBUDtBQUNEOzs7a0NBRWFELFEsRUFBVTtBQUN0QixVQUFNaEQsY0FBY0MsT0FBT0MsSUFBUCxDQUFZLEtBQUtOLFNBQWpCLENBQXBCOztBQUVBSSxrQkFBWThCLE9BQVosQ0FBb0IsVUFBU2pDLFVBQVQsRUFBcUI7QUFDdkMsWUFBTVUsU0FBUyxLQUFLWCxTQUFMLENBQWVDLFVBQWYsQ0FBZjs7QUFFQW1ELGlCQUFTekMsTUFBVDtBQUNELE9BSm1CLENBSWxCMkMsSUFKa0IsQ0FJYixJQUphLENBQXBCO0FBS0Q7OztxREFFdUNDLDRCLEVBQThCO0FBQ3BFLFVBQU12RCxZQUFZd0QsMENBQTBDRCw0QkFBMUMsQ0FBbEI7O0FBRUFFLHlCQUFtQkYsNEJBQW5CLEVBQWlEdkQsU0FBakQ7O0FBRUEsVUFBTTBELHVCQUF1QixJQUFJM0Qsb0JBQUosQ0FBeUJDLFNBQXpCLENBQTdCOztBQUVBLGFBQU8wRCxvQkFBUDtBQUNEOzs7aUNBRW1CQyxRLEVBQVU7QUFDNUJBLGVBQVNULElBQVQsQ0FBYyxVQUFTVSxXQUFULEVBQXNCQyxZQUF0QixFQUFvQztBQUNoRCxZQUFNQyxtQkFBbUJGLFlBQVlwQyxRQUFaLEVBQXpCO0FBQUEsWUFDTXVDLG9CQUFvQkYsYUFBYXJDLFFBQWIsRUFEMUI7O0FBR0EsWUFBSSxLQUFKLEVBQVcsQ0FFVixDQUZELE1BRVEsSUFBSXNDLG1CQUFtQkMsaUJBQXZCLEVBQTBDO0FBQ2hELGlCQUFPLENBQUMsQ0FBUjtBQUNELFNBRk8sTUFFQSxJQUFJRCxtQkFBbUJDLGlCQUF2QixFQUEwQztBQUNoRCxpQkFBTyxDQUFDLENBQVI7QUFDRDtBQUNGLE9BWEQ7QUFZRDs7Ozs7O0FBR0hDLE9BQU9DLE9BQVAsR0FBaUJsRSxvQkFBakI7O0FBRUEsU0FBU3lELHlDQUFULENBQW1ERCw0QkFBbkQsRUFBaUY7QUFDL0UsTUFBTXZELFlBQVksRUFBbEI7O0FBRUF1RCwrQkFBNkJyQixPQUE3QixDQUFxQyxVQUFTZ0MsMEJBQVQsRUFBcUN4RCxLQUFyQyxFQUE0QztBQUMvRSxRQUFNRCxPQUFPeUQsMkJBQTJCL0IsT0FBM0IsRUFBYjtBQUFBLFFBQ014QixTQUFTZixPQUFPZ0IsZ0JBQVAsQ0FBd0JILElBQXhCLEVBQThCQyxLQUE5QixDQURmOztBQUdBVixjQUFVUyxJQUFWLElBQWtCRSxNQUFsQjtBQUNELEdBTEQ7O0FBT0EsU0FBT1gsU0FBUDtBQUNEOztBQUVELFNBQVN5RCxrQkFBVCxDQUE0QkYsNEJBQTVCLEVBQTBEdkQsU0FBMUQsRUFBcUU7QUFDbkV1RCwrQkFBNkJyQixPQUE3QixDQUFxQyxVQUFTZ0MsMEJBQVQsRUFBcUM7QUFDeEVBLCtCQUEyQkMsbUJBQTNCLENBQStDLFVBQVNDLFlBQVQsRUFBdUI7QUFDcEUsVUFBTWxELGVBQWVrRCxhQUFhQyxlQUFiLEVBQXJCO0FBQUEsVUFDTWpELGVBQWVnRCxhQUFhRSxlQUFiLEVBRHJCO0FBQUEsVUFFTXpELG1CQUFtQkssYUFBYWlCLE9BQWIsRUFGekI7QUFBQSxVQUdNckIsbUJBQW1CTSxhQUFhZSxPQUFiLEVBSHpCO0FBQUEsVUFJTW9DLGlDQUFpQzFELGdCQUp2QztBQUFBLFVBSTBEO0FBQ3BEMkQscUNBQStCMUQsZ0JBTHJDO0FBQUEsVUFNTWUsNkJBQTZCN0IsVUFBVXVFLDhCQUFWLENBTm5DO0FBQUEsVUFNOEU7QUFDeEV6QyxpQ0FBMkI5QixVQUFVd0UsNEJBQVYsQ0FQakMsQ0FEb0UsQ0FRTTs7QUFFMUUzQyxpQ0FBMkJFLDJCQUEzQixDQUF1REQsd0JBQXZEOztBQUVBQSwrQkFBeUJFLDZCQUF6QixDQUF1REgsMEJBQXZEO0FBQ0QsS0FiRDtBQWNELEdBZkQ7QUFnQkQiLCJmaWxlIjoiZGlyZWN0ZWRBY3ljbGljR3JhcGguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFZlcnRleCA9IHJlcXVpcmUoJy4vdmVydGV4JyksXG4gICAgICBhcnJheVV0aWwgPSByZXF1aXJlKCcuL3V0aWwvYXJyYXknKTtcblxuY2xhc3MgRGlyZWN0ZWRBY3ljbGljR3JhcGgge1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhNYXApIHtcbiAgICB0aGlzLnZlcnRleE1hcCA9IHZlcnRleE1hcDtcbiAgfVxuXG4gIGFkZFZlcnRleEJ5VmVydGV4TmFtZSh2ZXJ0ZXhOYW1lKSB7XG4gICAgY29uc3QgdmVydGV4UHJlc2VudCA9IHRoaXMudmVydGV4TWFwLmhhc093blByb3BlcnR5KHZlcnRleE5hbWUpO1xuXG4gICAgaWYgKCF2ZXJ0ZXhQcmVzZW50KSB7XG4gICAgICBjb25zdCB2ZXJ0ZXhOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMudmVydGV4TWFwKSxcbiAgICAgICAgICAgIHZlcnRleE5hbWVzTGVuZ3RoID0gdmVydGV4TmFtZXMubGVuZ3RoLFxuICAgICAgICAgICAgbmFtZSA9IHZlcnRleE5hbWUsICAvLy9cbiAgICAgICAgICAgIGluZGV4ID0gdmVydGV4TmFtZXNMZW5ndGgsIC8vL1xuICAgICAgICAgICAgdmVydGV4ID0gVmVydGV4LmZyb21OYW1lQW5kSW5kZXgobmFtZSwgaW5kZXgpO1xuXG4gICAgICB0aGlzLnZlcnRleE1hcFt2ZXJ0ZXhOYW1lXSA9IHZlcnRleDtcbiAgICB9XG5cbiAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLnZlcnRleE1hcFt2ZXJ0ZXhOYW1lXTtcblxuICAgIHJldHVybiB2ZXJ0ZXg7XG4gIH1cblxuICBhZGRFZGdlQnlWZXJ0ZXhOYW1lcyhzb3VyY2VWZXJ0ZXhOYW1lLCB0YXJnZXRWZXJ0ZXhOYW1lKSB7XG4gICAgbGV0IGN5Y2xpY1ZlcnRpY2VzID0gbnVsbDtcblxuICAgIGlmIChzb3VyY2VWZXJ0ZXhOYW1lID09PSB0YXJnZXRWZXJ0ZXhOYW1lKSB7XG4gICAgICBjb25zdCBjeWNsaWNWZXJ0ZXhOYW1lID0gc291cmNlVmVydGV4TmFtZSwgIC8vL1xuICAgICAgICAgICAgY3ljbGljVmVydGV4ID0gdGhpcy52ZXJ0ZXhNYXBbY3ljbGljVmVydGV4TmFtZV07XG5cbiAgICAgIGN5Y2xpY1ZlcnRpY2VzID0gW2N5Y2xpY1ZlcnRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IHRoaXMuYWRkVmVydGV4QnlWZXJ0ZXhOYW1lKHNvdXJjZVZlcnRleE5hbWUpLFxuICAgICAgICAgICAgdGFyZ2V0VmVydGV4ID0gdGhpcy5hZGRWZXJ0ZXhCeVZlcnRleE5hbWUodGFyZ2V0VmVydGV4TmFtZSksXG4gICAgICAgICAgICBlZGdlUHJlc2VudCA9IHNvdXJjZVZlcnRleC5pc0VkZ2VQcmVzZW50QnlUYXJnZXRWZXJ0ZXgodGFyZ2V0VmVydGV4KTtcblxuICAgICAgaWYgKCFlZGdlUHJlc2VudCkge1xuICAgICAgICBjb25zdCBzb3VyY2VWZXJ0ZXhJbmRleCA9IHNvdXJjZVZlcnRleC5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICB0YXJnZXRWZXJ0ZXhJbmRleCA9IHRhcmdldFZlcnRleC5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICBpbnZhbGlkYXRpbmdFZGdlID0gKHNvdXJjZVZlcnRleEluZGV4ID4gdGFyZ2V0VmVydGV4SW5kZXgpO1xuXG4gICAgICAgIGlmIChpbnZhbGlkYXRpbmdFZGdlKSB7XG4gICAgICAgICAgY3ljbGljVmVydGljZXMgPSB0aGlzLnZhbGlkYXRlRWRnZShzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjeWNsZU1pc3NpbmcgPSAoY3ljbGljVmVydGljZXMgPT09IG51bGwpOyAvLy9cblxuICAgICAgICBpZiAoY3ljbGVNaXNzaW5nKSB7XG4gICAgICAgICAgY29uc3QgaW1tZWRpYXRlUHJlZGVjZXNzb3JWZXJ0ZXggPSBzb3VyY2VWZXJ0ZXgsIC8vL1xuICAgICAgICAgICAgICAgIGltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleCA9IHRhcmdldFZlcnRleDsgLy8vXG5cbiAgICAgICAgICBpbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleC5hZGRJbW1lZGlhdGVTdWNjZXNzb3JWZXJ0ZXgoaW1tZWRpYXRlU3VjY2Vzc29yVmVydGV4KTtcblxuICAgICAgICAgIGltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleC5hZGRJbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleChpbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY3ljbGljVmVydGV4TmFtZXM7XG5cbiAgICBpZiAoY3ljbGljVmVydGljZXMgIT09IG51bGwpIHtcbiAgICAgIGN5Y2xpY1ZlcnRleE5hbWVzID0gY3ljbGljVmVydGljZXMuZm9yRWFjaChmdW5jdGlvbihjeWNsaWNWZXJ0ZXgpIHtcbiAgICAgICAgY29uc3QgY3ljbGljVmVydGV4TmFtZSA9IGN5Y2xpY1ZlcnRleC5nZXROYW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIGN5Y2xpY1ZlcnRleE5hbWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3ljbGljVmVydGV4TmFtZXM7XG4gIH1cblxuICB2YWxpZGF0ZUVkZ2Uoc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpIHtcbiAgICBsZXQgY3ljbGljVmVydGljZXMgPSBudWxsO1xuXG4gICAgY29uc3QgZm9yd2FyZHNBZmZlY3RlZFZlcnRpY2VzID0gdGFyZ2V0VmVydGV4LmdldEZvcndhcmRzQWZmZWN0ZWRWZXJ0aWNlcyhzb3VyY2VWZXJ0ZXgpLFxuICAgICAgICAgIGxhc3RGb3J3YXJkc0FmZmVjdGVkVmVydGV4ID0gYXJyYXlVdGlsLmxhc3QoZm9yd2FyZHNBZmZlY3RlZFZlcnRpY2VzKSxcbiAgICAgICAgICBjeWNsZVByZXNlbnQgPSAobGFzdEZvcndhcmRzQWZmZWN0ZWRWZXJ0ZXggPT09IHNvdXJjZVZlcnRleCk7XG4gICAgXG4gICAgaWYgKGN5Y2xlUHJlc2VudCkge1xuICAgICAgY3ljbGljVmVydGljZXMgPSBmb3J3YXJkc0FmZmVjdGVkVmVydGljZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJhY2t3YXJkc0FmZmVjdGVkVmVydGljZXMgPSBzb3VyY2VWZXJ0ZXguZ2V0QmFja3dhcmRzQWZmZWN0ZWRWZXJ0aWNlcygpO1xuXG4gICAgICBEaXJlY3RlZEFjeWNsaWNHcmFwaC5zb3J0VmVydGljZXMoYmFja3dhcmRzQWZmZWN0ZWRWZXJ0aWNlcyk7XG5cbiAgICAgIERpcmVjdGVkQWN5Y2xpY0dyYXBoLnNvcnRWZXJ0aWNlcyhmb3J3YXJkc0FmZmVjdGVkVmVydGljZXMpO1xuXG4gICAgICBjb25zdCBhZmZlY3RlZFZlcnRpY2VzID0gW10uY29uY2F0KGJhY2t3YXJkc0FmZmVjdGVkVmVydGljZXMpLmNvbmNhdChmb3J3YXJkc0FmZmVjdGVkVmVydGljZXMpLFxuICAgICAgICAgICAgYWZmZWN0ZWRWZXJ0ZXhJbmRpY2VzID0gYWZmZWN0ZWRWZXJ0aWNlcy5tYXAoZnVuY3Rpb24oYWZmZWN0ZWRWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRWZXJ0ZXhJbmRleCA9IGFmZmVjdGVkVmVydGV4LmdldEluZGV4KCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGFmZmVjdGVkVmVydGV4SW5kZXg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgYWZmZWN0ZWRWZXJ0ZXhJbmRpY2VzLnNvcnQoKTtcblxuICAgICAgYWZmZWN0ZWRWZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKGFmZmVjdGVkVmVydGV4LCBpbmRleCkge1xuICAgICAgICBjb25zdCBhZmZlY3RlZFZlcnRleEluZGV4ID0gYWZmZWN0ZWRWZXJ0ZXhJbmRpY2VzW2luZGV4XTtcblxuICAgICAgICBhZmZlY3RlZFZlcnRleC5zZXRJbmRleChhZmZlY3RlZFZlcnRleEluZGV4KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjeWNsaWNWZXJ0aWNlcztcbiAgfVxuXG4gIG1hcFZlcnRleChjYWxsYmFjaykge1xuICAgIGNvbnN0IHZlcnRleE5hbWVzID0gT2JqZWN0LmtleXModGhpcy52ZXJ0ZXhNYXApLFxuICAgICAgICAgIHJlc3VsdCA9IHZlcnRleE5hbWVzLm1hcChmdW5jdGlvbih2ZXJ0ZXhOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLnZlcnRleE1hcFt2ZXJ0ZXhOYW1lXSxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHZlcnRleCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICBcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZm9yRWFjaFZlcnRleChjYWxsYmFjaykge1xuICAgIGNvbnN0IHZlcnRleE5hbWVzID0gT2JqZWN0LmtleXModGhpcy52ZXJ0ZXhNYXApO1xuXG4gICAgdmVydGV4TmFtZXMuZm9yRWFjaChmdW5jdGlvbih2ZXJ0ZXhOYW1lKSB7XG4gICAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLnZlcnRleE1hcFt2ZXJ0ZXhOYW1lXTtcblxuICAgICAgY2FsbGJhY2sodmVydGV4KTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ub3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzKHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMpIHtcbiAgICBjb25zdCB2ZXJ0ZXhNYXAgPSB2ZXJ0ZXhNYXBGcm9tVG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcyh0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzKTtcbiAgICBcbiAgICBhZGRFZGdlc1RvVmVydGljZXModG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcywgdmVydGV4TWFwKTtcbiAgICBcbiAgICBjb25zdCBkaXJlY3RlZEFjeWNsaWNHcmFwaCA9IG5ldyBEaXJlY3RlZEFjeWNsaWNHcmFwaCh2ZXJ0ZXhNYXApO1xuICAgIFxuICAgIHJldHVybiBkaXJlY3RlZEFjeWNsaWNHcmFwaDtcbiAgfVxuXG4gIHN0YXRpYyBzb3J0VmVydGljZXModmVydGljZXMpIHtcbiAgICB2ZXJ0aWNlcy5zb3J0KGZ1bmN0aW9uKGZpcnN0VmVydGV4LCBzZWNvbmRWZXJ0ZXgpIHtcbiAgICAgIGNvbnN0IGZpcnN0VmVydGV4SW5kZXggPSBmaXJzdFZlcnRleC5nZXRJbmRleCgpLFxuICAgICAgICAgICAgc2Vjb25kVmVydGV4SW5kZXggPSBzZWNvbmRWZXJ0ZXguZ2V0SW5kZXgoKTtcblxuICAgICAgaWYgKGZhbHNlKSB7XG5cbiAgICAgIH0gZWxzZSAgaWYgKGZpcnN0VmVydGV4SW5kZXggPCBzZWNvbmRWZXJ0ZXhJbmRleCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgIGlmIChmaXJzdFZlcnRleEluZGV4ID4gc2Vjb25kVmVydGV4SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICsxO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlyZWN0ZWRBY3ljbGljR3JhcGg7XG5cbmZ1bmN0aW9uIHZlcnRleE1hcEZyb21Ub3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzKHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMpIHtcbiAgY29uc3QgdmVydGV4TWFwID0ge307XG4gIFxuICB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24odG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXgsIGluZGV4KSB7XG4gICAgY29uc3QgbmFtZSA9IHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4LmdldE5hbWUoKSxcbiAgICAgICAgICB2ZXJ0ZXggPSBWZXJ0ZXguZnJvbU5hbWVBbmRJbmRleChuYW1lLCBpbmRleCk7XG5cbiAgICB2ZXJ0ZXhNYXBbbmFtZV0gPSB2ZXJ0ZXg7XG4gIH0pO1xuXG4gIHJldHVybiB2ZXJ0ZXhNYXA7XG59XG5cbmZ1bmN0aW9uIGFkZEVkZ2VzVG9WZXJ0aWNlcyh0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzLCB2ZXJ0ZXhNYXApIHtcbiAgdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4KSB7XG4gICAgdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXguZm9yRWFjaE91dGdvaW5nRWRnZShmdW5jdGlvbihvdXRnb2luZ0VkZ2UpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IG91dGdvaW5nRWRnZS5nZXRTb3VyY2VWZXJ0ZXgoKSxcbiAgICAgICAgICAgIHRhcmdldFZlcnRleCA9IG91dGdvaW5nRWRnZS5nZXRUYXJnZXRWZXJ0ZXgoKSxcbiAgICAgICAgICAgIHNvdXJjZVZlcnRleE5hbWUgPSBzb3VyY2VWZXJ0ZXguZ2V0TmFtZSgpLFxuICAgICAgICAgICAgdGFyZ2V0VmVydGV4TmFtZSA9IHRhcmdldFZlcnRleC5nZXROYW1lKCksXG4gICAgICAgICAgICBpbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleE5hbWUgPSBzb3VyY2VWZXJ0ZXhOYW1lLCAgLy8vXG4gICAgICAgICAgICBpbW1lZGlhdGVTdWNjZXNzb3JWZXJ0ZXhOYW1lID0gdGFyZ2V0VmVydGV4TmFtZSxcbiAgICAgICAgICAgIGltbWVkaWF0ZVByZWRlY2Vzc29yVmVydGV4ID0gdmVydGV4TWFwW2ltbWVkaWF0ZVByZWRlY2Vzc29yVmVydGV4TmFtZV0sIC8vL1xuICAgICAgICAgICAgaW1tZWRpYXRlU3VjY2Vzc29yVmVydGV4ID0gdmVydGV4TWFwW2ltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleE5hbWVdOyAvLy9cblxuICAgICAgaW1tZWRpYXRlUHJlZGVjZXNzb3JWZXJ0ZXguYWRkSW1tZWRpYXRlU3VjY2Vzc29yVmVydGV4KGltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleCk7XG5cbiAgICAgIGltbWVkaWF0ZVN1Y2Nlc3NvclZlcnRleC5hZGRJbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleChpbW1lZGlhdGVQcmVkZWNlc3NvclZlcnRleCk7XG4gICAgfSk7XG4gIH0pO1xufVxuIl19